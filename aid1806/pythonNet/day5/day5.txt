前情回顾

1. epoll 实现IO多路复用
2. 本地套接字：   AF_UNIX
    作用 ： 本地进程间的通信
3. 多任务编程
4. 多进程
    进程特征 : 最小的资源分配单元
               独立的空间
	       互不影响的运行状态
    进程状态 ： 就绪态   运行态   等待态
5.  创建进程
    os.fork()

    os.getpid()   os.getppid()
    os._exit()    sys.exit()
****************************************************

孤儿进程 ： 当父进程先于子进程退出，此时子进程就会成             为孤儿进程。

* 孤儿进程会被系统指定进程收养，即系统进程会成为孤儿   进程新的父进程。系统进程会自动处理孤儿进程退出状态

僵尸进程 ： 子进程先于父进程退出，父进程没有处理子进             程的退出状态，此时子进程就会成为僵尸进程

* 僵尸进程会滞留部分PCB信息在内存中，大量的僵尸进程会消耗系统的内存资源，所以要尽量避免僵尸进程产生

如何避免僵尸进程产生
* 父进程先退出
* 父进程处理子进程退出状态

pid,status = os.wait()
功能 ： 在父进程中阻塞等待处理子进程的退出
返回值：pid  退出的那个子进程的PID号
        status  子进程的退出状态

获取原来退出状态
os.WEXITSTATUS(status)

pid,status = os.waitpid(pid,option)
功能 ： 在父进程中阻塞等待处理子进程的退出
参数 ： pid    -1  表示等待任意子进程退出
               >0  表示等待对应PID号的子进程退出
	option   0   表示阻塞等待
	        WNOHANG  表示非阻塞
返回值：pid  退出的那个子进程的PID号
        status  子进程的退出状态

waitpid(-1,0)  ===> wait()

创建二级子进程

父进程创建子进程等待子进程退出
子进程创建下一级子进程，然后立即退出
二级子进程成为孤儿，处理具体工作


简单的群聊聊天室

功能 ： 类似于qq群聊
1. 进入聊天室需要输入姓名 姓名不能重复
2. 有人进入聊天室此时会向其他人发起通知
   xxx 进入了聊天室
3. 如果一个人发消息，则其他人都能收到
   xxx 说 ： xxxxxxx
4. 如果某个人退出聊天室其他人也会收到通知
   xxx 退出了聊天室
5. 服务端可以喊话 ：此时群里所有人都能收到服务端消息
   管理员 说：xxx

整体结构 ：分为几部分，如何封装，使用什么样的技术手段

服务端   客户端

在客户端和服务端每个功能封装为一个函数

技术方案：
转发 ： 一个客户端发送给服务器，服务器发送给其他人
套接字使用 ：udp 完成操作
用户存储： 字典 或者 列表  （可变类型，能够遍历提取）
           地址  用户名
发送和接受消息的控制：发送和接收使用多进程分离互不影响

注意事项：
1.注重封装
2.分段测试

代码编写流程

搭建通信  --》 创建多进程 ---》每个进程功能确定  --》 实现每一个功能模块

功能细节梳理

进入聊天室 
   客户端 ： 输入姓名 
             将信息发送给服务器  L name
	     接受到服务端返回结果判断下一步执行什么
   
   服务端 ： 接受消息
             判断请求类型
	     判断是否可以登录（姓名是否已经存在）
	     返回给客户端是否登录（如果可以服务端会将姓名插入到存储结构）
	     给所有人发送消息

聊天
      客户端 ： 发起聊天  C name msg
                接受服务器回复

      服务器 ： 接受消息 
                判断消息类型
		组织消息结构转发给其他客户端
	
退出聊天室
      客户端 ： 发送消息退出  Q  name
                接受回复
		退出程序
      服务端 ： 接受消息
                判断请求类型
		从用户结构删除对应用户
		告知所有人，xxx退出

multiprocessing 模块创建进程

1. 需要将要做的事情封装成函数
2. 使用multiprocessing提供的类Process创建进程对象
3. 通过进程对象和Process初始化进程进行进程的设置，绑    定函数
4. 启动进程，会自动执行绑定的函数
5. 完成进程的回收

创建进程对象
Process()
功能： 创建进程对象
参数： target ： 要绑定的函数
       name ： 给进程起的名称 （默认Process-1）
       args： 元组 用来给target函数位置传参
       kwargs : 字典  用来给target函数键值传参

p.start()
功能 ： 启动进程 自动运行terget绑定函数。此时进程被         创建

p.join([timeout])
功能： 阻塞等待子进程退出
参数： 超时时间

* 使用multiprocessing创建进程子进程同样复制父进程的全部内存空间，之后有自己独立的空间，执行上互不干扰
* 子进程也是有自己特有的PID等资源
* 如果不使用join回收可能会产生僵尸进程
* 使用multiprocessing创建子进程，一般父进程功能就是创建子进程回收子进程，所有事件交给子进程完成

作业 ： 1.梳理 聊天室代码
        2.对进程概念和创建过程巩固
	3.加深对http协议的理解
	4. 使用父子进程复制一个文件，分别复制文件的上半部分和下半部分到一个新的文件中。以字节区分


